**本蒟蒻第一次发题解,如有问题,敬请谅解**

首先,我利用了一个~~简单的~~函数来判断有没有问题——
```cpp
bool ok(int n, int l, int c)
{
	if (a[l][c] != 0 && a[l][c] != n)
		return false;
	for (int i = 1; i < N; i++)
		if ((s[i][c] == n && i != l) || (s[l][i] == n && i != c))
			return false;
	int aa = (int)(l / 3) * 3 + 1, bb = (int)(n / 3) * 3 + 1;
	for (int i = aa; i < aa + 3; i++)
		for (int j = bb; j < bb + 3; j++)
			if (s[i][j] == n && !(i == l && i == c))
				return false;
	return true;
}
```
提交进去， $\red{Unacceptd\ 5} $分！（就 $\#1\ \green{AC}$ ）
不管怎么优化，输出总是`-1`

——看来这条路走不通了！

想到以前8皇后的做法，我知道了怎么做。

~~众所周知，优化无极限。~~

所以，
## 正式题解开始！

```c
8 皇后的基本思路是：
用 4 个 bool 数组记录每一行、列、对角线是否有皇后，以达到快速判断的目的。而如果用这个方法做这道题的话……
就不会有误判导致的 -1 了
```

首先，**打表**一定要排在最前面

```cpp
// 分数
const int SCORE[10][10] = {
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 6, 6, 6, 6, 6, 6, 6, 6, 6},
	{0, 6, 7, 7, 7, 7, 7, 7, 7, 6},
	{0, 6, 7, 8, 8, 8, 8, 8, 7, 6},
	{0, 6, 7, 8, 9, 9, 9, 8, 7, 6},
	{0, 6, 7, 8, 9, 10,9, 8, 7, 6},
	{0, 6, 7, 8, 9, 9, 9, 8, 7, 6},
	{0, 6, 7, 8, 8, 8, 8, 8, 7, 6},
	{0, 6, 7, 7, 7, 7, 7, 7, 7, 6},
	{0, 6, 6, 6, 6, 6, 6, 6, 6, 6}};
```
```cpp
// 宫
const int GONG[10][10] = {
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9}};//打表yyds

```

然后就是一些全局变量：
```cpp
// 全局变量,用来保存结果和输入
int a[10][10];

// 全局变量,用来剑指
bool b[10][10];

// 全局变量,用来保存结果
int answer = -1;

bool used[3][10][10];
```
说明一下：

 $b$ 是后面 *人工* 优化用的，
 $b$ 为 $1$ 就说明**这个空输入时不是0，别管它**
。

 $used$ 是用来记录行、列、宫中有没有出现某数字，
如：
```cpp
used[0][l][a];
// 记录第 l 行是否有数字 a
used[1][c][a];
// 记录第 c 列是否有数字 a
used[2][GONG[l][c]][a];
// 记录格子 (l,c) 所在的宫是否有数字a
```

接下来写一个~~简单的~~ $function$ （函数）来计算分数：
```cpp
int score()
{
	int sum = 0;
	for (int i = 1; i <= 9; i++)
	{
		for (int j = 1; j <= 9; j++)
		{
			sum += a[i][j] * SCORE[i][j];
		}
	}
	return sum;
}
```
~~这真的很简单，所以我就不讲了~~

然后就是期待已久的 `dfs` 了！
```cpp
void dfs(int x, int y)
{
	if (b[x][y] != 0)// 人工优化
	{
		dfs(x, y + 1);
		return;
	}
	if (y > 9)
		dfs(x + 1, 1);
	if (x > 9)
	{
		int id1;
		id1 = score();//计分
		if (id1 > answer)
			answer = id1;
		return;
	}// 临界
	for (int i = 1; i <= 9; i++)
		if (used[0][x][i] == false && used[1][y][i] == false && used[2][GONG[x][y]][i] == false)
		{
			used[0][x][i] = used[1][y][i] = used[2][GONG[x][y]][i] = true;
			/*
			等同于：
			used[0][x][i] = true;
			used[1][y][i] = true;
			used[2][GONG[x][y]][i] = true;
			*/
			a[x][y] = i;
			dfs(x, y + 1);//下一层
			used[0][x][i] = used[1][y][i] = used[2][GONG[x][y]][i] = false;//还原
		}
}
```
还有主程序：
```cpp
int main()
{
	for (int i = 1; i <= 9; i++)
	{
		for (int j = 1; j <= 9; j++)
		{
			scanf("%d", &a[i][j]);
			if (a[i][j] != 0)
			{
				b[i][j] = used[0][i][a[i][j]] = used[1][j][a[i][j]] = used[2][GONG[i][j]][a[i][j]] = true;
			}
		}
	}
	dfs(1, 1);
	printf("%d", answer);
}
```
结果？
$总分\ \red{Unaccepted}\ \green{80},4个点\gray{TLE}$

有图为证：
![](https://cdn.luogu.com.cn/upload/image_hosting/s4i37xiq.png)

### 确实，
~~众所周知，优化无极限。~~

_______________

那怎么才能 $\green{AC}$ 呢？
于是，我下载了点2，

发现……
```
0 0 0 0 0 6 0 0 3
0 0 0 0 0 0 6 0 0
0 0 0 0 0 3 0 0 0
0 0 0 1 0 0 2 0 0
0 0 0 0 3 0 0 0 4
0 2 7 0 0 0 0 3 0
1 0 0 0 6 8 4 7 9
0 9 6 2 7 0 1 0 5
8 0 0 0 9 0 3 0 0
```
左上角都是0！怪不得会 $\gray{TLE}$ 呢！

于是，我把`dfs`和主程序都修改了一下：
### dfs:
```cpp
void dfs(int x, int y)
{
	if (b[x][y] != 0)
	{
		dfs(x, y + 1);
		return;
	}
	if (y > 9)
		dfs(x - 1, 1);
	if (x == 0)// 修改
	{
		int id1;
		id1 = score();
		if (id1 > answer)
			answer = id1;
		return;
	}
	for (int i = 1; i <= 9; i++)
		...
}
```
### 主程序:
```cpp
int main()
{
	...
	dfs(9, 1);// 修改
	printf("%d", answer);
}
```
从左下角开始搜， $\green{Accepted}!$ 
完结撒完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

// 分数(打表yyds)
const int SCORE[10][10] = {
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 6, 6, 6, 6, 6, 6, 6, 6, 6},
	{0, 6, 7, 7, 7, 7, 7, 7, 7, 6},
	{0, 6, 7, 8, 8, 8, 8, 8, 7, 6},
	{0, 6, 7, 8, 9, 9, 9, 8, 7, 6},
	{0, 6, 7, 8, 9, 10, 9, 8, 7, 6},
	{0, 6, 7, 8, 9, 9, 9, 8, 7, 6},
	{0, 6, 7, 8, 8, 8, 8, 8, 7, 6},
	{0, 6, 7, 7, 7, 7, 7, 7, 7, 6},
	{0, 6, 6, 6, 6, 6, 6, 6, 6, 6}};

// 宫(打表yyds)
const int GONG[10][10] = {
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9}};

// 全局变量,用来保存结果和输入
int a[10][10];

// 全局变量,用来剑指
bool b[10][10];

// 全局变量,用来保存结果
int answer = -1;

bool used[3][10][10];

// 统计函数
int score()
{
	int sum = 0;
	for (int i = 1; i <= 9; i++)
	{
		for (int j = 1; j <= 9; j++)
		{
			sum += a[i][j] * SCORE[i][j];
		}
	}
	return sum;
}

// 深收
void dfs(int x, int y)
{
	if (b[x][y] != 0)
	{
		dfs(x, y + 1);
		return;
	}
	if (y > 9)
		dfs(x - 1, 1);
	if (x == 0)
	{
		int id1;
		id1 = score();
		if (id1 > answer)
			answer = id1;
		return;
	}
	for (int i = 1; i <= 9; i++)
		if (used[0][x][i] == false && used[1][y][i] == false && used[2][GONG[x][y]][i] == false)
		{
			used[0][x][i] = used[1][y][i] = used[2][GONG[x][y]][i] = true;
			a[x][y] = i;
			dfs(x, y + 1);
			used[0][x][i] = used[1][y][i] = used[2][GONG[x][y]][i] = false;
		}
}

// 主程序
int main()
{

	for (int i = 1; i <= 9; i++)
	{
		for (int j = 1; j <= 9; j++)
		{
			scanf("%d", &a[i][j]);
			if (a[i][j] != 0)
			{
				b[i][j] = used[0][i][a[i][j]] = used[1][j][a[i][j]] = used[2][GONG[i][j]][a[i][j]] = true;
			}
		}
	}
	dfs(9, 1);
	printf("%d", answer);
}

```
